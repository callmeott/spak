package spak;
import java.io.*;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;
import org.w3c.dom.Node;

/**
 * <p>Title: XMLReader</p>
 * <p>Description: Parse SPAK's Knowledge file in XML format</p>
 * <p>Copyright: Copyright (c) 2002</p>
 * <p>Company: </p>
 * @author Vuthichai
 * @version 1.0
 *
 * $Log: XMLReader.java,v $
 * Revision 1.1  2005-08-02 07:30:34  pattara
 * -first import
 *
 * Revision 1.8  2005/04/08 10:23:46  pattara
 * -new slot flag: DF (Don't Fill). In case of the R (Required flag) is set,
 *  when inducing, if this flag is set, the inference engine will NOT try to
 *  find a value for it, otherwise it will help finding a value (default behavior)
 *
 * Revision 1.7  2005/03/23 09:48:32  pattara
 * -today's change
 *
 * Revision 1.6  2004/11/25 16:22:08  pattara
 * -OK, Beginning Only flag is working now
 *
 * Revision 1.5  2004/07/28 04:59:20  vuthi
 * 1) Add file filter for .xml, .js, etc.
 * 2) Improve slot editor. Disable editing of non-related attributes.
 * 3) Implement UNIQUE attribute. Allow network client to update
 *     non-unique required values of existing Instances.
 * 4) Add/Implement "onUpdate" slot.
 *
 * Revision 1.4  2004/07/26 03:32:44  vuthi
 * Add "Unique" field and ability to save/load in/out of XML file.
 * Maintain compatibility with earlier Knowledge file with no UNIQUE tag.
 *
 */

public class XMLReader {
  KFrame rootFrame = null;
  static Document document;
  Hashtable frameObject = new Hashtable();
  Vector vectorISA = new Vector();

  public XMLReader() {
  }

  void parseFile(String filename) {
    DocumentBuilderFactory factory =
        DocumentBuilderFactory.newInstance();
    //factory.setValidating(true);
    //factory.setNamespaceAware(true);
    try {
      DocumentBuilder builder = factory.newDocumentBuilder();
      FileInputStream fi = new FileInputStream(filename);
      System.out.println("Parsing XML");
      document = builder.parse(fi);
      fi.close();
      System.out.println("Parsing XML: DONE");
      org.w3c.dom.NodeList frameList = document.getChildNodes();

      frameObject.clear();
      vectorISA.removeAllElements();
      org.w3c.dom.Node topNode = frameList.item(0);

      if(topNode.getNodeName().equals("FRAME")) {
        rootFrame = buildTree(frameList.item(0),null);
      }
      else if(topNode.getNodeName().equals("FRAMELIST")) {
        frameList = topNode.getChildNodes();
        for(int i=0;i<frameList.getLength();i++)
          buildTree(frameList.item(i), rootFrame);
        // Build IS-A Relationship
        checkISA();
      }
    }
    catch (SAXParseException spe) {
      // Error generated by the parser
      System.out.println("\n** Parsing error"
                         + ", line " + spe.getLineNumber()
                         + ", uri " + spe.getSystemId());
      System.out.println("   " + spe.getMessage() );

      // Use the contained exception, if any
      Exception  x = spe;
      if (spe.getException() != null)
        x = spe.getException();
      x.printStackTrace();

    } catch (SAXException sxe) {
      // Error generated during parsing)
      Exception  x = sxe;
      if (sxe.getException() != null)
        x = sxe.getException();
      x.printStackTrace();

    } catch (ParserConfigurationException pce) {
      // Parser with specified options can't be built
      pce.printStackTrace();

    } catch (IOException ioe) {
      // I/O error
      ioe.printStackTrace();
    }
  }

  KFrame buildTree(org.w3c.dom.Node node, KFrame rootFrame) {
    if(node.getNodeName().equals("FRAME")) {
      org.w3c.dom.NodeList nodeList = node.getChildNodes();
      KFrame myFrame = new KFrame(findNodeValue("NAME", nodeList), rootFrame);

      // Map from Frame name to KFrame Object
      frameObject.put(myFrame.getName(), myFrame);
//      System.out.println("Name is "+myFrame.getName());

      // Check if it's an instance
      if(findNodeValue("ISINSTANCE", nodeList).equals("TRUE"))
        myFrame.setInstance(true);

      // Check if it's an instance
      String showchildren = findNodeValue("SHOWCHILDREN", nodeList);
      if(showchildren != null) {
        if (showchildren.equals("TRUE"))
          myFrame.setChildVisible(true);
        else
          myFrame.setChildVisible(false);
      }

      // Add IS-A Relationships
      this.fillISA(myFrame.getName(), nodeList);

      // Add Slots
      org.w3c.dom.Node slotList = findNode("SLOTLIST", nodeList);
      if(slotList != null) {
        org.w3c.dom.NodeList slotNodeList = slotList.getChildNodes();
        for(int i=0;i<slotNodeList.getLength();i++) {
          org.w3c.dom.Node slot = slotNodeList.item(i);
          if(slot.getNodeName().equals("SLOT")) {
            org.w3c.dom.NodeList slotargs = slot.getChildNodes();

            // XML files saved by Early version of SPAK dont have UNIQUE and REQB fields.
            // Need to check if it is NULL.
            String uniStr = findNodeValue("UNIQUE",slotargs);
            String reqbStr = findNodeValue("REQUIREDB",slotargs);
            String dfStr = findNodeValue("DONTFILL",slotargs);
            myFrame.addSlot(findNodeValue("NAME",slotargs),
                            findNodeValue("VALUE",slotargs),
                            Slot.findTypeValue(findNodeValue("TYPE",slotargs)),
                            Slot.findConditionValue(findNodeValue("CONDITION",slotargs)),
                            findNodeValue("ARGUMENT",slotargs),
                            findNodeValue("REQUIRED",slotargs).equals("TRUE"),
                            reqbStr==null?false:(reqbStr.equals("TRUE")),
                            dfStr==null?false:(dfStr.equals("TRUE")),
                            findNodeValue("SHARED",slotargs).equals("TRUE"),
                            uniStr==null?true:(uniStr.equals("TRUE"))
                            );
          }
        }
      }

      // Add Child Nodes
      org.w3c.dom.Node frameList = findNode("FRAMELIST", nodeList);
      if(frameList != null) {
        org.w3c.dom.NodeList frameNodeList = frameList.getChildNodes();
        if(rootFrame==null)
          rootFrame = myFrame;
        for(int i=0;i<frameNodeList.getLength();i++) {
          KFrame child = buildTree(frameNodeList.item(i), rootFrame);
          if(child!=null)
            myFrame.add(child);
        }
      }
      return myFrame;
    }
    else
      return null;
  }

  void checkISA() {
    Hashtable findRoot = new Hashtable();
    findRoot.putAll(frameObject);

    for(int i=0;i<vectorISA.size();i+=2) {
      String name1 = (String)vectorISA.elementAt(i);
      String name2 = (String)vectorISA.elementAt(i+1);
      KFrame obj1 = (KFrame)frameObject.get(name1);
      KFrame obj2 = (KFrame)frameObject.get(name2);
//      System.out.println("ISA: "+name1+"-"+name2);
      obj2.add(obj1);
      if(findRoot.containsKey(name1))
        findRoot.remove(name1);
    }
    if(findRoot.size()>1)
      System.out.println("This XML file has more than one Root frame !!!! "+findRoot.size());
    // Return the first possible root frame (frame with no parent)
    rootFrame = (KFrame)findRoot.elements().nextElement();
  }

  void fillISA(String nname, org.w3c.dom.NodeList nodeList) {
    int count = nodeList.getLength();
    for (int i=0; i<count; i++) {
        org.w3c.dom.Node node = nodeList.item(i);
        if(node.getNodeName().equals("ISA")) {
          vectorISA.add(nname);
          vectorISA.add(getNodeContent(node));
        }
    }
  }

  String findNodeValue(String nname, org.w3c.dom.NodeList nodeList) {
    int count = nodeList.getLength();
    for (int i=0; i<count; i++) {
        org.w3c.dom.Node node = nodeList.item(i);
        if(node.getNodeName().equals(nname))
          return getNodeContent(node);
//        else
//          System.out.println("Name: "+node.getNodeName()+" <> "+nname);
    }
    return null;
  }

  org.w3c.dom.Node findNode(String nname, org.w3c.dom.NodeList nodeList) {
    int count = nodeList.getLength();
    for (int i=0; i<count; i++) {
        org.w3c.dom.Node node = nodeList.item(i);
        if(node.getNodeName().equals(nname))
          return node;
//        else
//          System.out.println("Name: "+node.getNodeName()+" <> "+nname);
    }
    return null;
  }

  public KFrame getRootNode() {
    return rootFrame;
  }

  static final int ELEMENT_TYPE =   Node.ELEMENT_NODE;
  static final int ATTR_TYPE =      Node.ATTRIBUTE_NODE;
  static final int TEXT_TYPE =      Node.TEXT_NODE;
  static final int CDATA_TYPE =     Node.CDATA_SECTION_NODE;
  static final int ENTITYREF_TYPE = Node.ENTITY_REFERENCE_NODE;
  static final int ENTITY_TYPE =    Node.ENTITY_NODE;
  static final int PROCINSTR_TYPE = Node.PROCESSING_INSTRUCTION_NODE;
  static final int COMMENT_TYPE =   Node.COMMENT_NODE;
  static final int DOCUMENT_TYPE =  Node.DOCUMENT_NODE;
  static final int DOCTYPE_TYPE =   Node.DOCUMENT_TYPE_NODE;
  static final int DOCFRAG_TYPE =   Node.DOCUMENT_FRAGMENT_NODE;
  static final int NOTATION_TYPE =  Node.NOTATION_NODE;

  public String getNodeContent(org.w3c.dom.Node domNode) {
    String s = "";
    org.w3c.dom.NodeList nodeList = domNode.getChildNodes();
    for (int i=0; i<nodeList.getLength(); i++) {
      org.w3c.dom.Node node = nodeList.item(i);
      int type = node.getNodeType();
      if (type == ELEMENT_TYPE) {
        s += "<" + node.getNodeName() + "> ... ";
        s += "</" + node.getNodeName() + ">";
      } else if (type == TEXT_TYPE) {
        s += node.getNodeValue();
      } else if (type == ENTITYREF_TYPE) {
        // The content is in the TEXT node under it
        s += getNodeContent(node);
      } else if (type == CDATA_TYPE) {
        // The "value" has the text, same as a text node.
        //   while EntityRef has it in a text node underneath.
        //   (because EntityRef can contain multiple subelements)
        // Convert angle brackets and ampersands for display
        StringBuffer sb = new StringBuffer( node.getNodeValue() );
        for (int j=0; j<sb.length(); j++) {
          if (sb.charAt(j) == '<') {
            sb.setCharAt(j, '&');
            sb.insert(j+1, "lt;");
            j += 3;
          } else if (sb.charAt(j) == '&') {
            sb.setCharAt(j, '&');
            sb.insert(j+1, "amp;");
            j += 4;
          }
        }
        s += "<pre>" + sb + "\n</pre>";
      }
      // Ignoring these:
      //   ATTR_TYPE      -- not in the DOM tree
      //   ENTITY_TYPE    -- does not appear in the DOM
      //   PROCINSTR_TYPE -- not "data"
      //   COMMENT_TYPE   -- not "data"
      //   DOCUMENT_TYPE  -- Root node only. No data to display.
      //   DOCTYPE_TYPE   -- Appears under the root only
      //   DOCFRAG_TYPE   -- equiv. to "document" for fragments
      //   NOTATION_TYPE  -- nothing but binary data in here
    }
    return s;
  }
}